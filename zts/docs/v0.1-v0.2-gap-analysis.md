# ZTS v0.1 vs v0.2 Gap Analysis

## Context

This document maps every section of the v0.2 spec against the current v0.1 implementation in the `zts/` compiler/engine layer only. Server-layer concerns (`src/server.zig`, `src/zruntime.zig`, `src/main.zig`) are out of scope.

---

## 1. File and Module Model

### 1.1 Source file extensions

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| `*.zts.ts` canonical | Not recognized. v0.1 uses `.js`, `.jsx`, `.ts`, `.tsx` |
| `*.zts` optional | Not recognized |

**Gap:** New extension recognition needed in the compiler entry points. The `.zts.ts` extension would also need TS stripping + ZTS-specific passes.

### 1.2 Module system

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| ESM `import`/`export` | Tokenized, IR nodes exist, but parser does not dispatch them - falls through to error. Interpreter has stub handlers (push undefined / discard). No module loader, resolver, or registry. |
| No CommonJS | Already absent (no `require`/`module.exports`) |
| No dynamic `import()` | Already absent |

**Gap:** Full module system implementation needed: parser dispatch for `import`/`export` statements, module resolution (relative paths + virtual modules), module registry, import binding semantics.

### 1.3 Virtual modules

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| `zts:std` | Does not exist |
| `zts:rt` | Does not exist |

**Gap:** Entirely new. Requires a virtual module resolver that intercepts `zts:*` specifiers and returns pre-defined type/value exports. `zts:std` surfaces the Effect namespace, Err namespace, capability interfaces, and standard capabilities. `zts:rt` provides the runtime harness with `run`.

---

## 2. Core Principles

### 2.1 "Only one way" enforcement

v0.1 already bans many alternatives (46+ features detected in parser, 7+ in stripper), but the enforcement is for a different purpose - simplifying the FaaS runtime. v0.2 requires new bans specific to the ZTS language (e.g., free-function equivalents of `Effect.*`, non-pipe sequencing patterns).

**Gap:** New validation pass needed after parsing to enforce v0.2-specific canonical forms. Current bans are a subset of what v0.2 requires.

### 2.2 No hidden magic / `zts explain`

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| `zts explain` command | Does not exist. No desugar tracking infrastructure in the compiler. |
| Desugar reporting | No infrastructure |

**Gap:** The compiler needs to produce desugar tracking metadata: pipe rewrite locations, nominal mint/unmint insertion points, comptime evaluation spans. CLI is out of scope but the compiler must expose this data.

### 2.3 `zts eject`

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| Emit TS project from ZTS source | Does not exist |

**Gap:** Entirely new. Reverse compilation: ZTS AST back to TypeScript source with pipes removed, comptime embedded, nominal conversions explicit, runtime harness generated.

---

## 3. Language Surface: Pipe Operator

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| `\|>` token | No `\|>` token in tokenizer. `scanPipe()` only produces `\|`, `\|\|`, `\|\|=`, `\|=` |
| Pipe as left-associative operator | No parser support |
| `_` placeholder in pipe RHS | No placeholder concept |
| Pipe rewrite semantics | No desugaring pass |
| 5 pipe diagnostics (`RETS_PIPE_*`) | No diagnostics infrastructure for v0.2 codes |

**Gap:** Major new feature touching tokenizer, parser, IR (new node type), desugaring pass, and diagnostics. This is one of the largest additions.

---

## 4. Forbidden Constructs

### Already banned in v0.1

These v0.2 bans are already enforced:

- `class` (parser) - `new` (parser) - `this` (parser) - `super` (parser)
- decorators (stripper) - `namespace` (stripper) - `enum` (stripper)
- `async`/`await` - parsed but await is a no-op; v0.2 wants compile error
- `Promise` - explicitly blocked in parser

### New bans needed for v0.2

| v0.2 Ban | v0.1 Status |
|----------|-------------|
| Prototype mutation (`X.prototype.y`, `__proto__`) | Not banned - would need runtime or parser check |
| Direct Promise APIs in user code | `Promise` global is banned, but no ban on `then()`/`catch()` on values |

### Changes needed

- `async`/`await`: v0.1 silently accepts and ignores `await`. v0.2 requires compile-time errors.
- Prototype mutation: needs new detection in parser or semantic analysis.

---

## 5. Effects Model

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| `Effect<A, E>` type | Does not exist |
| `Effect.pure/map/flatMap/catch/then` | Does not exist |
| `Caps` interface combining capabilities | Does not exist |
| `run()` executor (runtime-only) | Does not exist |
| `export const main: Effect<number, Err.Any>` | Handler is `function handler(req) {...}` - completely different entrypoint model |
| `run` forbidden in user modules | No concept |

**Gap:** The most fundamental architectural change. v0.1's execution model is request-response HTTP handlers. v0.2's model is algebraic effects with capability injection. This is not an incremental addition - it's a different programming model.

The v0.1 `Result.ok/err/match` builtin is a rudimentary precursor, but it lacks the monadic composition (`map`, `flatMap`, `catch`, `then`) and the capability threading.

---

## 6. Capability Interfaces

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| `/** @zts capability */ interface` | Interfaces are stripped entirely by the stripper. No runtime representation. |
| Interface forbidden except for capabilities | All interfaces silently stripped (no error) |
| Console capability (log + error) | `console.log` exists as global builtin. No `console.error`. Not capability-gated. |
| Clock capability (nowMs, sleepMs) | `Date.now()` and `performance.now()` exist as globals. No `sleepMs`. Not capability-gated. |
| Random capability (u32, bytes) | `Math.random()` exists as global. No `u32()` or `bytes()`. Not capability-gated. |
| Process capability (args, envGet, cwd, exit) | None exist. `Env.VARIABLE_NAME` exists only in comptime. |
| Fs capability (readText, writeText, readBytes, writeBytes) | No filesystem access at all |
| Net capability (http) | `httpRequest()` exists behind `--outbound-http` flag. JSON bridge, not capability-gated. |

**Gap:** Massive. The entire capability system is new. Current globals would need to be removed from the global scope and restructured as capability interface implementations. The `@zts capability` JSDoc marker needs to be recognized by the stripper/parser instead of being stripped.

---

## 7. Runtime Execution

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| Single execution point: `caps \|> run(_, main)` | No `main` export convention. No `run` function. Handler convention is `function handler(req)`. |
| `zts:rt` runtime harness | Does not exist |
| `run` forbidden in user code | No concept |

**Gap:** The compiler needs to validate the `export const main: Effect<number, Err.Any>` entrypoint convention and enforce that `run` is not called in user modules. The actual execution harness is a server-layer concern, but the compiler must validate the contract.

---

## 8. Errors as Values

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| `Err.Def<Name, Fields>` | Does not exist |
| `Err.ctor(name, mkMessage)` | Does not exist |
| `Err.is(e, name)` | Does not exist |
| `Err.match(e, cases)` | Does not exist |
| `Err.Any` | Does not exist |
| Ban on `class X extends Error` | `class` is already banned |
| Ban on ad-hoc `{tag: ...}` error objects | Not banned |
| `RETS_ERROR_*` diagnostics | Do not exist |

**Gap:** The `Result.ok/err/match` builtin in v0.1 is related but different. v0.2's `Err.*` namespace provides error definition, construction, narrowing, and matching. This needs to be implemented in the `zts:std` virtual module and enforced by the validator.

---

## 9. Nominal Types

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| `nominal type T: R;` syntax | Does not exist - no mention of "nominal" anywhere |
| Representation constraints (primitives only) | N/A |
| Minting/unminting rules | N/A |
| `RETS_NOMINAL_*` diagnostics | N/A |

**Gap:** Entirely new language feature. Needs tokenizer changes (new keyword or contextual keyword), parser support, a new IR node, semantic validation (module-scoped minting), and cast insertion pass.

---

## 10. Comptime

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| `comptime(() => expr)` | `comptime(expr)` exists in `comptime.zig` - no arrow function wrapper |
| Deterministic subset | Already enforced - no `Math.random()`, `Date.now()`, etc. |
| Must be serializable to literal AST | Already serializes results to JS literals |
| `RETS_COMPTIME_*` diagnostics | Generic error reporting only, no v0.2 diagnostic codes |

**Gap:** Syntactic change from `comptime(expr)` to `comptime(() => expr)`. The arrow function wrapper is new. The underlying evaluator is largely compatible - the main work is adjusting the syntax recognition in the stripper and adding v0.2 diagnostic codes.

This is one of the smallest gaps.

---

## 11. Build Targets

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| `zts build` CLI | CLI is out of scope. The compiler pipeline itself is relevant. |
| Native target | Bytecode + JIT produces native execution |
| WASM/WASI target (default) | No WASM codegen backend in the compiler |
| `zts eject` to TS | No AST-to-source emitter exists |

**Gap:** The compiler needs a WASM codegen backend (pass 8) and a TS emitter (pass 9 for eject). CLI wrapping is out of scope but these are compiler capabilities.

---

## 12. Compilation Passes (v0.2 vs v0.1)

v0.2 specifies 9 passes:

| # | v0.2 Pass | v0.1 Equivalent |
|---|-----------|-----------------|
| 1 | Parse ZTS to AST | Parser produces IR (flat SoA, not tree AST) |
| 2 | Desugar pipe to TS-shaped AST | Does not exist |
| 3 | Evaluate comptime | Exists (in stripper pass, before parsing) |
| 4 | Collect declarations (nominals, capabilities, main, errors) | Scope analysis collects bindings, but none of the v0.2 declaration types |
| 5 | Validate bans + canonical forms | Partial - bans exist but not v0.2-specific ones |
| 6 | Insert nominal casts at explicit sites | Does not exist |
| 7 | Lower to HIR then Zig backends | IR to bytecode exists. AIR (SSA/CFG) exists for optimized JIT but is disabled. No HIR as specified. |
| 8 | Codegen native or WASI | Native codegen via JIT. No WASI. |
| 9 | (Eject) Emit TS + runtime harness | Does not exist |

**Gap:** Passes 2, 4 (partial), 6, 9 are entirely new. Pass 7 needs restructuring - current flow is IR -> bytecode -> JIT native, v0.2 wants IR -> HIR -> Zig backends.

---

## 13. Diagnostics

| v0.2 Spec | v0.1 Status |
|-----------|-------------|
| Named diagnostic codes (`RETS_PIPE_*`, `RETS_CAP_*`, etc.) | No diagnostic codes. Errors use `ErrorKind` enum + free-form message strings. |
| ~30 v0.2-specific diagnostics | 0 of these exist |

**Gap:** Need to add a diagnostic code system alongside the existing `ErrorKind` enum. All v0.2 diagnostics (`RETS_PIPE_*`, `RETS_CAP_INTERFACE_*`, `RETS_NOMINAL_*`, `RETS_MAIN_*`, `RETS_EFFECT_*`, `RETS_COMPTIME_*`, `RETS_OOP_*`, `RETS_ERROR_*`) are new.

---

## Summary: Gap Size by Feature

| Feature | Gap Size | Notes |
|---------|----------|-------|
| Effects model + capabilities | Huge | Architectural paradigm shift from request-handler to algebraic effects |
| Module system (`import`/`export`) | Large | IR skeleton exists but no implementation |
| Pipe operator (`\|>`) | Large | Tokenizer + parser + desugaring pass |
| Nominal types | Large | Entirely new language feature |
| Capability interfaces | Large | New JSDoc marker, new validation, new runtime implementations |
| WASM codegen backend | Large | New codegen target in the compiler |
| TS emitter (for eject) | Large | Reverse compilation from IR/AST back to TypeScript |
| Desugar tracking (for explain) | Medium | Compiler must produce metadata about rewrites |
| Errors as values (`Err.*`) | Medium | New namespace, validation, but builds on existing `Result` concept |
| Virtual modules (`zts:std`, `zts:rt`) | Medium | New resolver + predefined exports |
| Compilation passes restructuring | Medium | New passes for pipe desugaring, nominal casts, declaration collection |
| Diagnostics codes | Medium | Systematic but mechanical |
| File extensions (`.zts.ts`, `.zts`) | Small | Extension recognition in compiler entry points |
| Comptime syntax change | Small | `comptime(expr)` to `comptime(() => expr)` |
| Additional OOP bans | Small | Prototype mutation, ad-hoc error objects |
| `async`/`await` hard ban | Small | Change from silent ignore to compile error |

### zts/ features that v0.2 doesn't need

These v0.1 compiler features have no equivalent in the v0.2 spec:

- JSX/TSX parsing and codegen (`http.zig`: `h()`, `renderToString()`, `Fragment`) - not in v0.2 spec
- HTTP-specific builtins: `Response.*`, `Request` shape preallocations, HTTP atoms (`context.zig`, `object.zig`)
- `Result.ok/err/match` builtins (`builtins.zig`) - replaced by `Err.*` namespace
- Most globals as free-standing builtins (`console.log`, `Math.random`, `Date.now`) - become capability-gated
- Handler pattern dispatch / handler analysis (`handler_analyzer.zig`) - server concern

### What carries forward (zts/ reusable components)

- **Tokenizer** (`parser/tokenizer.zig`) - needs `|>` token and `nominal` keyword added
- **Pratt parser** (`parser/parse.zig`) - core expression parsing reusable, needs new productions
- **IR** (`parser/ir.zig`) - SoA layout reusable, needs new node types for pipe, nominal
- **Bytecode** (`bytecode.zig`) - format and opcodes largely reusable
- **Interpreter** (`interpreter.zig`) - reusable for v0.2 bytecode execution
- **JIT** (`jit/`) - baseline JIT reusable; optimized tier remains dead code
- **Value system** (`value.zig`, `object.zig`) - NaN-boxing, hidden classes reusable
- **Memory system** (`gc.zig`, `heap.zig`, `arena.zig`, `pool.zig`) - reusable
- **Comptime evaluator** (`comptime.zig`) - reusable with syntax adjustment
- **TypeScript stripper** (`stripper.zig`) - reusable, needs new rules for `@zts capability`
- **Scope analysis** (`parser/scope.zig`) - reusable, needs module scope support
- **Inline caching / PIC** - reusable
- **String interning / intern pool** - reusable
