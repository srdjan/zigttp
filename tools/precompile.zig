//! Build-time TypeScript/JavaScript precompiler
//!
//! Compiles handler files to bytecode at build time for embedding in the binary.
//! This eliminates runtime parsing overhead and removes the need for source files
//! in deployment.
//!
//! Usage: precompile <handler.ts> <output.zig>

const std = @import("std");
const zts = @import("zts");

/// Read a file synchronously using posix operations
fn readFilePosix(allocator: std.mem.Allocator, path: []const u8, max_size: usize) ![]u8 {
    const path_z = try allocator.dupeZ(u8, path);
    defer allocator.free(path_z);

    const fd = try std.posix.openatZ(std.posix.AT.FDCWD, path_z, .{ .ACCMODE = .RDONLY }, 0);
    defer std.posix.close(fd);

    const stat = try std.posix.fstat(fd);
    const file_size: usize = @intCast(@max(0, stat.size));

    if (file_size > max_size) return error.FileTooBig;

    const buffer = try allocator.alloc(u8, file_size);
    errdefer allocator.free(buffer);

    var total_read: usize = 0;
    while (total_read < file_size) {
        const bytes_read = try std.posix.read(fd, buffer[total_read..]);
        if (bytes_read == 0) break;
        total_read += bytes_read;
    }

    return buffer[0..total_read];
}

/// Write a file synchronously using posix operations
fn writeFilePosix(path: []const u8, data: []const u8, allocator: std.mem.Allocator) !void {
    const path_z = try allocator.dupeZ(u8, path);
    defer allocator.free(path_z);

    const fd = try std.posix.openatZ(
        std.posix.AT.FDCWD,
        path_z,
        .{ .ACCMODE = .WRONLY, .CREAT = true, .TRUNC = true },
        0o644,
    );
    defer std.posix.close(fd);

    var total_written: usize = 0;
    while (total_written < data.len) {
        const result = std.c.write(fd, data[total_written..].ptr, data.len - total_written);
        if (result < 0) return error.WriteFailure;
        if (result == 0) return error.WriteFailure;
        total_written += @intCast(result);
    }
}

pub fn main(init: std.process.Init.Minimal) !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Parse command line arguments
    var args = std.process.Args.Iterator.init(init.args);
    defer args.deinit();

    // Skip program name
    _ = args.skip();

    const handler_path = args.next() orelse {
        std.debug.print("Usage: precompile <handler.ts> <output.zig>\n", .{});
        std.debug.print("\nCompiles a TypeScript/JavaScript handler to bytecode.\n", .{});
        return error.MissingArgument;
    };

    const output_path = args.next() orelse {
        std.debug.print("Usage: precompile <handler.ts> <output.zig>\n", .{});
        std.debug.print("\nMissing output path.\n", .{});
        return error.MissingArgument;
    };

    // Read the handler source file (using posix for synchronous I/O)
    const source = readFilePosix(allocator, handler_path, 10 * 1024 * 1024) catch |err| {
        std.debug.print("Error reading handler file '{s}': {}\n", .{ handler_path, err });
        return err;
    };
    defer allocator.free(source);

    std.debug.print("Compiling handler: {s} ({d} bytes)\n", .{ handler_path, source.len });

    // Compile the handler to bytecode
    const bytecode_data = compileHandler(allocator, source, handler_path) catch |err| {
        std.debug.print("Compilation failed: {}\n", .{err});
        return err;
    };
    defer allocator.free(bytecode_data);

    std.debug.print("Generated bytecode: {d} bytes\n", .{bytecode_data.len});

    // Write the output Zig file
    writeZigFile(output_path, bytecode_data, allocator) catch |err| {
        std.debug.print("Error writing output file '{s}': {}\n", .{ output_path, err });
        return err;
    };

    std.debug.print("Wrote embedded handler to: {s}\n", .{output_path});
}

fn compileHandler(allocator: std.mem.Allocator, source: []const u8, filename: []const u8) ![]const u8 {
    var source_to_parse: []const u8 = source;
    var strip_result: ?zts.StripResult = null;
    defer if (strip_result) |*sr| sr.deinit();

    // Type strip for .ts/.tsx files
    const is_ts = std.mem.endsWith(u8, filename, ".ts");
    const is_tsx = std.mem.endsWith(u8, filename, ".tsx");

    if (is_ts or is_tsx) {
        // Build comptime environment with build metadata
        const comptime_env = zts.ComptimeEnv{
            .build_time = null, // TODO: pass actual build time
            .git_commit = null, // TODO: pass git commit
            .version = zts.version.string,
            .env_vars = null,
        };

        strip_result = zts.strip(allocator, source, .{
            .tsx_mode = is_tsx,
            .enable_comptime = true,
            .comptime_env = comptime_env,
        }) catch |err| {
            std.debug.print("TypeScript strip error: {}\n", .{err});
            return err;
        };
        source_to_parse = strip_result.?.code;
        std.debug.print("TypeScript stripped successfully\n", .{});
    }

    // Initialize string table and atom table for parsing
    var strings = zts.StringTable.init(allocator);
    defer strings.deinit();

    var atoms = zts.context.AtomTable.init(allocator);
    defer atoms.deinit();

    // Parse the source code
    var parser = zts.Parser.init(allocator, source_to_parse, &strings, &atoms);
    defer parser.deinit();

    // Enable JSX mode for .jsx and .tsx files
    if (std.mem.endsWith(u8, filename, ".jsx") or is_tsx) {
        parser.enableJsx();
    }

    const bytecode_data = parser.parse() catch |err| {
        // Print parse errors
        const errors = parser.js_parser.getErrors();
        if (errors.len > 0) {
            for (errors) |parse_error| {
                std.debug.print("Parse error at {s}:{}:{}: {s}\n", .{
                    filename,
                    parse_error.location.line,
                    parse_error.location.column,
                    parse_error.message,
                });
            }
        }
        return err;
    };

    std.debug.print("Parsed successfully: {d} bytes of bytecode\n", .{bytecode_data.len});

    // Create FunctionBytecode struct to wrap the parsed result
    const func = zts.FunctionBytecode{
        .header = .{},
        .name_atom = 0,
        .arg_count = 0,
        .local_count = parser.max_local_count,
        .stack_size = 256,
        .flags = .{},
        .code = bytecode_data,
        .constants = parser.constants.items,
        .source_map = null,
    };

    // Get object literal shapes from parser
    const shapes = parser.getShapes();
    std.debug.print("Collected {d} object literal shapes\n", .{shapes.len});

    // Serialize bytecode with atoms AND shapes for complete cache format
    var buffer: [256 * 1024]u8 = undefined; // 256KB buffer
    var writer = zts.bytecode_cache.SliceWriter{ .buffer = &buffer };

    zts.bytecode_cache.serializeBytecodeWithAtomsAndShapes(&func, &atoms, shapes, &writer, allocator) catch |err| {
        std.debug.print("Serialization error: {}\n", .{err});
        return err;
    };

    // Copy the serialized data to owned memory
    const serialized = writer.getWritten();
    return try allocator.dupe(u8, serialized);
}

fn writeZigFile(path: []const u8, bytecode_data: []const u8, allocator: std.mem.Allocator) !void {
    // Estimate output size: header (~100 bytes) + 8 chars per byte + newlines
    const estimated_size = 200 + bytecode_data.len * 8;
    var output = try allocator.alloc(u8, estimated_size);
    defer allocator.free(output);

    var pos: usize = 0;

    // Write header comment
    const header =
        \\//! Auto-generated embedded handler bytecode
        \\//! Do not edit - regenerate with: zig build -Dhandler=<path>
        \\
        \\pub const bytecode = [_]u8{
        \\
    ;
    @memcpy(output[pos..][0..header.len], header);
    pos += header.len;

    // Write bytes in rows of 16 for readability
    var i: usize = 0;
    while (i < bytecode_data.len) {
        // Write indentation
        @memcpy(output[pos..][0..4], "    ");
        pos += 4;

        const row_end = @min(i + 16, bytecode_data.len);
        while (i < row_end) {
            // Format: "0xNN, " (6 chars)
            const byte = bytecode_data[i];
            output[pos] = '0';
            output[pos + 1] = 'x';
            output[pos + 2] = hexChar(@truncate(byte >> 4));
            output[pos + 3] = hexChar(@truncate(byte & 0x0f));
            output[pos + 4] = ',';
            output[pos + 5] = ' ';
            pos += 6;
            i += 1;
        }
        output[pos] = '\n';
        pos += 1;
    }

    // Write closing
    const footer = "};\n";
    @memcpy(output[pos..][0..footer.len], footer);
    pos += footer.len;

    // Write to file using posix
    try writeFilePosix(path, output[0..pos], allocator);
}

fn hexChar(n: u4) u8 {
    const hex_chars = "0123456789abcdef";
    return hex_chars[n];
}
